__all__ = [ 'PackageDir', ]

import os
import shlex

import portage.manifest

import logging
logging.getLogger ( __name__ ).warning ( "experimental code" )
del logging

import roverlay.config
import roverlay.strutil
import roverlay.packageinfo
import roverlay.overlay.pkgdir.packagedir_base
import roverlay.overlay.pkgdir.symlink.distroot

class PackageDir ( roverlay.overlay.pkgdir.packagedir_base.PackageDirBase ):

	MANIFEST_THREADSAFE = True

	def _scan_add_package ( self, efile, pvr ):
		"""Called for each ebuild that is found during scan().
		Creates a PackageInfo for the ebuild and adds it to self._packages.

		arguments:
		* efile -- full path to the ebuild file
		* pvr   -- version ($PVR) of the ebuild
		"""

		# read SRC_URI from the ebuild file which is the only way to get
		# the correct package name
		src_uri = None
		with open ( efile, 'r' ) as FH:
			reader                   = shlex.shlex ( FH )
			reader.whitespace_split  = False
			reader.wordchars        += ' ,./$()[]:+-@*~<>'

			# assumption: only one SRC_URI= statement per ebuild
			# (true for roverlay ebuilds)
			mode  = 0
			token = reader.get_token()
			while token:
				if mode == 0 and token == 'SRC_URI':
					mode = 1
				elif mode == 1 and token == '=':
					mode = 2
				elif mode == 2:
					mode = 3
					src_uri = tuple (
						roverlay.strutil.split_whitespace (
							roverlay.strutil.unquote ( token )
						)
					)

				# break loop if SRC_URI parsed
				token = reader.get_token() if mode < 3 else None
			# --- while;
			del token, reader, mode
		# --- with;

		if src_uri:
			# another assumption: src_uri [0] is the name of the R package
			package_filename = src_uri [0].rpartition ( '/' ) [2]

			p = roverlay.packageinfo.PackageInfo (
				physical_only=True, pvr=pvr, ebuild_file=efile,
				package_filename=package_filename
			)
		else:
			p = roverlay.packageinfo.PackageInfo (
				physical_only=True, pvr=pvr, ebuild_file=efile
			)

			self._packages [ p ['ebuild_verstr'] ] = p
	# --- end of _scan_add_package (...) ---

	def write_manifest ( self, ignore_empty=False ):
		"""Generates and writes the Manifest file for this package.

		expects: called after writing metadata/ebuilds

		returns: success (True/False)

		raises:
		* Exception if no ebuild exists
		"""

		# the "package_filename" key is also required
		pkgs_for_manifest = frozenset (
			p for p in self._packages.values()
				if p.has ( 'ebuild_filename', 'package_file' )
		)

		# TODO: this needs proper testing
		# * the written Manifest file must not differ from the one generated by
		#   ebuild(1) (the order of the entries is not important, though)
		# * safe for incremental usage?
		# * correct usage of the portage libs (also see other comments below)
		# * what happens if an ebuild has been removed?
		# * ...
		#
		if pkgs_for_manifest:
			symlink_distdir = roverlay.overlay.pkgdir.symlink.distroot.\
				SymlinkDistroot.get_configured().get ( self.name )

			# allow_missing=True -- don't write empty Manifest files
			manifest = portage.manifest.Manifest (
				self.physical_location,
				str ( symlink_distdir ),
				allow_missing=True,
			)

			# metadata.xml
			# os.path.basename ( self._metadata.filepath )
			manifest.addFile ( 'MISC', 'metadata.xml' )

			for p in pkgs_for_manifest:
				ebuild_filename  = p ['ebuild_filename']
				package_filename = p ['package_filename']

				if not manifest.hasFile ( 'EBUILD', ebuild_filename ):
					manifest.addFile ( 'EBUILD', ebuild_filename )

				if not manifest.hasFile ( 'DIST', package_filename ):
					symlink_distdir.add ( p ['package_file'], package_filename )
					manifest.addFile (
						'DIST',
						package_filename,
						# TODO:
						# ignoreMissing for DIST files, else addFile raises
						# FileNotFound -- is this the correct way to add DIST files?
						ignoreMissing=True
					)

			# ??? FIXME: (read) portage api docs
			#
			# manifest.create -- recreate from scratch (required?)
			# -> assumeDistHashesSometimes:
			#     use existing checksums for non-existent DIST files (required?)
			#
			#manifest.create ( assumeDistHashesSometimes=True )
			#manifest.create ( assumeDistHashesSometimes=False )

			manifest.write()
			self._need_manifest = False

			return True

		elif ignore_empty:

			return True

		else:
			raise Exception (
				'In {mydir}: No ebuild written so far! '
				'I really don\'t know what do to!'.format (
					mydir=self.physical_location
			) )

		# @unreachable
		return False
	# --- end of write_manifest (...) ---
