# R overlay -- overlay package, package directory (portage manifest)
# -*- coding: utf-8 -*-
# Copyright (C) 2013 Andr√© Erdmann <dywi@mailerd.de>
# Distributed under the terms of the GNU General Public License;
# either version 2 of the License, or (at your option) any later version.

__all__ = [ 'PackageDir', ]

import os
import shlex

import portage.manifest

import logging
logging.getLogger ( __name__ ).warning ( "experimental code" )
del logging

import roverlay.config
import roverlay.strutil
import roverlay.packageinfo
import roverlay.overlay.pkgdir.packagedir_base
import roverlay.overlay.pkgdir.distroot

class PackageDir ( roverlay.overlay.pkgdir.packagedir_base.PackageDirBase ):

	MANIFEST_THREADSAFE = True

	def _scan_add_package ( self, efile, pvr ):
		"""Called for each ebuild that is found during scan().
		Creates a PackageInfo for the ebuild and adds it to self._packages.

		arguments:
		* efile -- full path to the ebuild file
		* pvr   -- version ($PVR) of the ebuild
		"""

		# read SRC_URI from the ebuild file which is the only way to get
		# the correct package name
		src_uri = None
		with open ( efile, 'r' ) as FH:
			reader                   = shlex.shlex ( FH )
			reader.whitespace_split  = False
			reader.wordchars        += ' ,./$()[]:+-@*~<>'

			# assumption: only one SRC_URI= statement per ebuild
			# (true for roverlay ebuilds)
			mode  = 0
			token = reader.get_token()
			while token:
				if mode == 0 and token == 'SRC_URI':
					mode = 1
				elif mode == 1 and token == '=':
					mode = 2
				elif mode == 2:
					mode = 3
					src_uri = tuple (
						roverlay.strutil.split_whitespace (
							roverlay.strutil.unquote ( token )
						)
					)

				# break loop if SRC_URI parsed
				token = reader.get_token() if mode < 3 else None
			# --- while;
			del token, reader, mode
		# --- with;

		if src_uri:
			# another assumption: src_uri [0] is the name of the R package
			package_filename = src_uri [0].rpartition ( '/' ) [2]

			p = roverlay.packageinfo.PackageInfo (
				physical_only=True, pvr=pvr, ebuild_file=efile,
				package_filename=package_filename
			)
		else:
			p = roverlay.packageinfo.PackageInfo (
				physical_only=True, pvr=pvr, ebuild_file=efile
			)
		# --- if;

		self._packages [ p ['ebuild_verstr'] ] = p
	# --- end of _scan_add_package (...) ---

	def _write_manifest ( self, pkgs_for_manifest ):
		"""Generates and writes the Manifest file for this package.

		expects: called after writing metadata/ebuilds

		returns: True
		"""

		# TODO: this needs proper testing
		# * the written Manifest file must not differ from the one generated by
		#   ebuild(1) (the order of the entries is not important, though)
		# * safe for incremental usage?
		# * correct usage of the portage libs (also see other comments below)
		# * what happens if an ebuild has been removed?
		# * ...
		#

		distdir = roverlay.overlay.pkgdir.distroot.get_distdir ( self.name )

		# allow_missing=True -- don't write empty Manifest files
		manifest = portage.manifest.Manifest (
			self.physical_location,
			distdir.get_root(),
			allow_missing=True,
		)

		# metadata.xml
		# os.path.basename ( self._metadata.filepath )
		manifest.addFile ( 'MISC', 'metadata.xml' )

		for p in pkgs_for_manifest:

			ebuild_filename  = p ['ebuild_filename']
			package_filename = p ['package_filename']

			if not manifest.hasFile ( 'EBUILD', ebuild_filename ):
				manifest.addFile ( 'EBUILD', ebuild_filename )

			if not manifest.hasFile ( 'DIST', package_filename ):
				distdir.add ( p ['package_file'], package_filename )
				manifest.addFile (
					'DIST',
					package_filename,
					# TODO:
					# ignoreMissing for DIST files, else addFile raises
					# FileNotFound -- is this the correct way to add DIST files?
					ignoreMissing=True
				)

		# ??? FIXME: (read) portage api docs
		#
		# manifest.create -- recreate from scratch (required?)
		# -> assumeDistHashesSometimes:
		#     use existing checksums for non-existent DIST files (required?)
		#
		#manifest.create ( assumeDistHashesSometimes=True )
		#manifest.create ( assumeDistHashesSometimes=False )

		manifest.write()
		self._need_manifest = False

		return True
	# --- end of write_manifest (...) ---
