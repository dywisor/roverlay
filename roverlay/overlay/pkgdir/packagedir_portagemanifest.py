# R overlay -- overlay package, package directory (portage manifest)
# -*- coding: utf-8 -*-
# Copyright (C) 2013 Andr√© Erdmann <dywi@mailerd.de>
# Distributed under the terms of the GNU General Public License;
# either version 2 of the License, or (at your option) any later version.

__all__ = [ 'PackageDir', ]

import os
import shlex

import portage.manifest
import portage.exception

import logging
logging.getLogger ( __name__ ).warning ( "experimental code" )
del logging

import roverlay.config
import roverlay.strutil
import roverlay.packageinfo
import roverlay.overlay.pkgdir.packagedir_base
import roverlay.overlay.pkgdir.distroot

class PackageDir ( roverlay.overlay.pkgdir.packagedir_base.PackageDirBase ):

   MANIFEST_THREADSAFE = True

   def _scan_add_package ( self, efile, pvr ):
      """Called for each ebuild that is found during scan().
      Creates a PackageInfo for the ebuild and adds it to self._packages.

      arguments:
      * efile -- full path to the ebuild file
      * pvr   -- version ($PVR) of the ebuild
      """

      # read SRC_URI from the ebuild file which is the only way to get
      # the correct package name
      src_uri = None
      with open ( efile, 'r' ) as FH:
         reader                   = shlex.shlex ( FH )
         reader.whitespace_split  = False
         reader.wordchars        += ' ,./$()[]:+-@*~<>'

         # assumption: only one SRC_URI= statement per ebuild
         # (true for roverlay ebuilds)
         mode  = 0
         token = reader.get_token()
         while token:
            if mode == 0 and token == 'SRC_URI':
               mode = 1
            elif mode == 1 and token == '=':
               mode = 2
            elif mode == 2:
               mode = 3
               src_uri = tuple (
                  roverlay.strutil.split_whitespace (
                     roverlay.strutil.unquote ( token )
                  )
               )

            # break loop if SRC_URI parsed
            token = reader.get_token() if mode < 3 else None
         # --- while;
         del token, reader, mode
      # --- with;

      # another assumption:
      #  name of the R package is src_uri[2] if src_uri[1] == '->', else [0]
      #
      if src_uri:
         # > 2, > 1? ebuild would be broken if $SRC_URI ends with '->'
         #if len ( src_uri ) > 2 and src_uri [1] == '->':
         if len ( src_uri ) > 1 and src_uri [1] == '->':
            package_filename = src_uri[2]
         else:
            package_filename = src_uri[0].rpartition ( '/' ) [2]

         p = roverlay.packageinfo.PackageInfo (
            physical_only=True, pvr=pvr, ebuild_file=efile,
            package_filename=package_filename
         )
      else:
         p = roverlay.packageinfo.PackageInfo (
            physical_only=True, pvr=pvr, ebuild_file=efile
         )
      # --- if;

      self._packages [ p ['ebuild_verstr'] ] = p
   # --- end of _scan_add_package (...) ---

   def _write_manifest ( self, pkgs_for_manifest ):
      """Generates and writes the Manifest file for this package.

      expects: called after writing metadata/ebuilds

      returns: True
      """

      # TODO: this needs proper testing
      # * the written Manifest file must not differ from the one generated by
      #   ebuild(1) (the order of the entries is not important, though)
      # * safe for incremental usage?
      # * correct usage of the portage libs (also see other comments below)
      # * what happens if an ebuild has been removed?
      # * ...
      #

      distdir = roverlay.overlay.pkgdir.distroot.get_distdir ( self.name )

      # allow_missing=True -- don't write empty Manifest files
      manifest = portage.manifest.Manifest (
         self.physical_location,
         distdir.get_root(),
         allow_missing=True,
      )

      # metadata.xml
      #os.path.basename ( self._metadata.filepath )
      try:
         manifest.addFile ( 'MISC', 'metadata.xml' )
      except portage.exception.FileNotFound as f404:
         # package dir has no metadata.xml file
         #
         # This happens for a few package dirs that dont contain any package
         # with enough information required for metadata creation
         #
         # packagedir_ebuildmanifest accepts this case without complaining,
         # so ignore it here, too.
         #
         pass


      for p in pkgs_for_manifest:

         ebuild_filename  = p ['ebuild_filename']
         package_filename = p ['package_src_destpath']

         if not manifest.hasFile ( 'EBUILD', ebuild_filename ):
            manifest.addFile ( 'EBUILD', ebuild_filename )

         if not manifest.hasFile ( 'DIST', package_filename ):
            distdir.add ( p ['package_file'], package_filename )
            manifest.addFile (
               'DIST',
               package_filename,
               # TODO:
               # ignoreMissing for DIST files, else addFile raises
               # FileNotFound -- is this the correct way to add DIST files?
               ignoreMissing=True
            )
         else:
            # ebuildmanifest adds all package files to the distdir without
            # doing the check above (if hasFile())
            # be "fully compatible" and do that here, too
            try:
               distdir.add ( p ['package_file'], package_filename )
            except Exception as err:
               self.logger.exception ( err )

      # ??? FIXME: (read) portage api docs
      #
      # manifest.create -- recreate from scratch (required?)
      # -> assumeDistHashesSometimes:
      #     use existing checksums for non-existent DIST files (required?)
      #
      #manifest.create ( assumeDistHashesSometimes=True )
      #manifest.create ( assumeDistHashesSometimes=False )

      manifest.write()
      return True
   # --- end of write_manifest (...) ---
