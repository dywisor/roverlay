#! NOPARSE
#
# simple dependency rules file
#
# This file has been replaced by the dep rule files in simple-deprules.d/,
# but explains the syntax.
#
# === Syntax ===
#
# You can specify single and multiline rules here,
#  the basic syntax is "<portage identifier> <matches> <keyword(s)>".
#
#
# There are two types of dependency string matching:
#  standard : a dep string has to match exactly
#              "R(>=2.15)" != "R" => UNRESOLVABLE
#
#  fuzzy    : the resolver will try to find a match using string
#              interpolation/metrics
#               "R(>=2.15)" ~ "R" => ">=dev-lang/R-2.15"
#               "R(!=2.15)" ~ "R" => "(!dev-lang/R-2.15 dev-lang/R)"
#               "R(>=2.15)" % "R" => <ignored> (% is fuzzy ignore)
#
#
# a single line entry looks like
## (1)  <portage package> :: <dependency string>  (standard simple dep)
## (2) ~<portage package> :: <dependency string>  (fuzzy simple dep)
## (3)  <dependency string>                       (standard selfdep)
## (4) ~<dependency string>                       (fuzzy selfdep)
## (5) ! :: <dependency string>                   (standard ignored dep)
## (6) % :: <dependency string>                   (fuzzy ignored dep)
#
# Dependency strings are case-insensitive.
#
# (3) and (4) are shortcuts for [~]<overlay category>/<dep> :: <dep>,
#  e.g. "fftw" matches "fftw" and resolves to "sci-R/fftw".
#  This is useful 'cause you don't have to use a hardcoded overlay category
#  here.
# (5) and (6) are ways to define deps that should be ignored
#  (=resolved to nothing). They're identical to (1)/(2), but use ! / % as
#  portage package.
#
#
# a multiline entry looks like
## [~]<portage package> {
## <dependency string 1>
## <dependency string 2>
## ...
## <dependency string n>
## }
#
# selfdeps cannot be declared in a multiline rule
#
# The precedence order of the rules in this file is
## single line ignore > single line > multi line ignore > multi line
#### this has to be fixed in the dep rule reader
#
# Note:
# * you cannot write comments in a multiline rule, writing
## dev-lang/R {
##  # the following dep should resolve to R
##  R(>= 2.15.0)
## }
# means that both strings '# the following dep should resolve to R' and
# 'R(>= 2.15.0)' resolve to 'dev-lang/R'!
#
# * compound portage dependency statements (man 5 ebuild) are supported,
#   but only in standard simple deps, e.g.
## || ( <dev-lang/R-2.14.0 >dev-lang/R-2.14.0 ) :: R (!= 2.14.0)
#
#

# === Examples ===

# == single line entries ==

# = standard simple dep =
# this rule matches 'R (>= 2.15.0)' and resolves it as 'dev-lang/R-2.15.0'
dev-lang/R-2.15.0 :: R (>= 2.15.0)

# = fuzzy simple dep =

# this rule matches
## (a) R <version modifier?> <version>
## (b) R (<version modifier?> <version>)
## (c) R [<version modifier?> <version>]
## (d) R {<version modifier?> <version>}
## (e) R
# variant (a) is whitespace sensitive (>= 1 whitespace char between R and
# the version modifier/version), the others ignore all whitespace chars.
# variant (e) is the standard simple rule behaviour.
#
# the dep string is then resolved as <version modifier?>dev-lang/R-<version>
#
# version modifier is optional and can be one out of {>=, <=, >, <, !=, =, ! },
# where ! / != are being resolved a 'specific version is forbidden'.
# '>=' is assumed as version modifier if it is left out and a specific version
# is required.
#
# examples matches:
# (a) r 2.13       -> >=dev-lang/R-2.13
# (b) R(>= 2.14)   -> >=dev-lang/R-2.14
# (c) R [<2.10]    -> <dev-lang/R-2.10
# (d) r{  !2.12 }  -> ( !=dev-lang/R-2.12 dev-lang/R )
# (e) R            -> dev-lang/R
#
~dev-lang/R :: R

# = standard selfdep =
# resolves "tuneR","tuner",.. as "sci-R/tuneR"
tuneR

# = fuzzy selfdep =
# * see fuzzy simple dep
# example match: resolves "zoo 1.10" as ">=sci-R/zoo-1.10"
~zoo

# = standard ignored dep =
# ignores "R"
! :: R

# = fuzzy ignored dep =
# ignores everything that fuzzy-matches R (see fuzzy simple dep)
% :: R

# == multi line entries ==

# = simple multiline rule =
# matches "R (>= 2.15)", "R" and resolves them as dev-lang/R
dev-lang/R {
	R (>= 2.15)
	R
}

# = fuzzy multiline rule =
~dev-lang/R {
	R
	the R programming language
}

# = ignored dep multiline rule =
# equals ! :: see README
! {
	see README
}

# = fuzzy ignored dep multiline rule =
# equals % :: R
% {
	R
}

# === Extra ===

# There's a special keyword that tells the rule reader to stop parsing,
# see line #1. It has to be exactly '#! NOPARSE' or '#! BREAK', with no
# additional content at the end of the line.
#! NOPARSE
#! BREAK
